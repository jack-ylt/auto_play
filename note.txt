btm 密码 qQ198...


git status
git add .
git commit -m

git push origin master
git push origin multi_client
git push --delete origin branch_name_here

git branch
git checkout

git log
                

★ 现在已经实现一键挂机了

下一步是把所有情况都考虑上，提高挂机稳定性
涉及到切界面的要考虑monitor，因为有时候快有时候慢

优化图片，很多图片重复
ok1 ok2，也没法区分

monitor_than_click()
find_then_click(name_list, pos=None, timeout=5, raise_exception=True)


    async def _fight(self):
        """do fight, return win or lose"""
        await self.player.find_then_click(['start_fight', 'fight1'])
        await asyncio.sleep(3)
        await self.player.find_then_click(['fast_forward1'], raise_exception=False)
        await asyncio.sleep(10)
        await self.player.find_then_click(['go_last'])
        pos_ok = (430, 430)
        result = await self.player.find_then_click(['win', 'lose'], pos=pos_ok, timeout=240)
        await asyncio.sleep(3)
        return result
        
        吉安县畜牧兽医局 07968442451
        



换区 change server
    make sure in main ui
    find and click setting
    find and click server icon
    wait until no find empty board
    
    if right top server is new server icon
        return false

    click the right top server icon
    click ok
    find setting
    return true
    
    
关卡战斗
    find and click gkzd
    if no find
        move to center
        find and click gkzd
    wait untile find goback icon
    
    # for ther first 10 days of new player
    if find close btn (1s)
        find and click 'can recive'
        find and click ok
        find and then click close
    
    click box
    click recive btn
    
    monitor [upgraded fight next pass]
    
    if find upgrade(upgrade and unlock new map)
        find and click ok
        sleep 5s
        move to center
        find and click gkzd
        wait untile find goback icon 
        
        monitor [fight next pass]

    if find fight btn
        click
        find and click fight btn
    elif find next level btn
        click
        click search
        wait 3 s (10s, vip at least 3s)
        find and click fight btn
        find and click fight btn
    elif pass
        if find nex_level_point
            click
            if find  search
                click
            else
                return
        else 
            find and click the rightest next_level_flag
            if find search
                click
                if find pass
                    click map
            else
                return
            
    
    while true

        try:
            do fight
                ...
                click ok
                
            monitor [upgrade next]
            if upgrade
                hand_upgrade
            
            nextlevel_to_fight
        except fight_lose:
            return
        except reach_max_level:
            return
            
    


挑战副本
    find and click tzfb
    


公会挑战


勇者副本


VIP shop


主程序逻辑

场景一：一键游戏
    初始化账号列表
    启动多个模拟器
    old_account = None

    对于每个客户端
        try
            account_dict = 登录一个新账号
            old_account = account_dict
        except
            没账号了：exit

        if server_list:
            for 对于每一个服务器
                切换到该的服务器

                玩游戏
        else
            玩游戏

登录一个新账号
    if old_account：
        获取一个账号（指定游戏名）
        if 成功：
            登录
        else
            关闭游戏
            获取一个账号
            根据游戏名，启动游戏
            登录
    else
        获取一个账号
        根据游戏名，启动游戏
        登录
        

场景二：继续游戏 （需要记录哪些角色玩过了，哪些任务已完成）


冠军试炼
    如果不是周日下午
        退出
        如果已经获得了200积分
            退出
    点竞技场
    点冠军试炼
    点进入
    如果 战斗说明
        点 close
        如果英雄出战
            点保存
    i=4
    j=1
    score = 0
    
    while score < 50:
        点战斗
        点 刷新 i 次
        点 j 战斗
        
        点战斗
        monitor
        if 下一场 或 确定 或 快进
            点
        if card
            点卡片 2 次
            if win
                score += 2  
                win += 1
            else
                score += 1
                lose += 1
                j += 1
                if j > 3:
                    j = 1
                    i += 1

            点确定

    log win xx lose yy


英雄远征
hero_expedition
production_workshop
one_click_collection
    到右上角
    点英雄远征
    点生产车间
    点一键领取


模板匹配，会因为大小不同，分辨率不同，匹配失败
    试试特征点匹配


很多按钮突然识别不了了，应该是按钮的指纹变了
=》 可能是截图完整的按钮没问题，只截文字有问题 （文字细节会变化）（如果有多个按钮，可能会误识别）
=》 使用其他标志图标，然后，按位置点击


如何实现一键游戏，做到完全省心？
    图像识别准确
    每个逻辑都独立，并覆盖所有情况
    每个任务都可以配置，做到遵循玩家意愿
    结束后，有个报告，告知任务完成情况，让玩家放心
    即使出现问题，也不影响别的
    出现预料之外的情况，有记录，可追溯
    出现游戏bug，无响应等异常，能重启游戏


开发中遇到的阻碍：
    很多情况没有考虑到
    -》 伪代码

    截图太麻烦
    -> 截有特色的, 使用好的截图软件

    api记不住
    -> Shpinx 自动生成项目文档

    代码框架感觉有点混乱了
    -> 重新理一下


main
    创建 recorder
        加载 json 到 dict

    windows_num = 启动模拟器 (如果已经启动，直接返回窗口数)
    根据窗口数，创建玩家
    
    对于每一个玩家，添加协程任务 auto_play
        try:
            角色 = 登录游戏
        except:
            exit

        对于每一个未完成的任务 + 多多益善的任务（根据json）
            try:
                执行任务 （可能用到 role recorder）
            except:
                xxx

            try：
                回主界面
            except：
                重启游戏
        
    退出之前：
        dict -> json
        

    登录游戏
        if 在主界面了
            if 角色为空
                role = 获取登录的角色名 (退出，复制用户名)
                绑定角色
            else
                role = apply_new_role
                重新登录 role
        else (游戏未启动)
            启动游戏，自动登录游戏
            role = 获取登录的角色名
            try：
                绑定角色
            except
                role = apply_new_role
                重新登录 role

        return role

    重新登录
        退出
        登录 role

先实现不要账号密码的

eye，hand
    提供基础api，方便第一，不考虑效率

player
    和window结合，方便auto_play调用，提供缓存，考虑效率

tasks
    利用 player，role 完成每一个任务

login
    启动模拟器，登录游戏

recorder
    记录每个role的任务完成情况
    load
    record
    report

account.cfg
    game_name = mo_shi_jun_tun
    account = aa592729440
    passwd = Qq8738090

setting.cfg 
    [default]
    cfg of all task ...

    [account1]
    cfg of all task ...

    [account2]
    ...

pics 
    bottom
    icon
    pic

支持各种大小的窗口
    截图最大的窗口，然后通过剪切、缩小，得到各种尺寸的图片

每个player有单独的日志记录

写个测试，测试下，使用with的多进程查找 
    估计不会有性能问题
    
没必要把hand、eye分开，直接都集成到player中去，参考pyautogui



☆ 研究下别人的代码实现
    img.resize()
    
    屏幕截图，避免保存和读取的过程
        from PIL import ImageGrab
        from io import BytesIO
        import numpy as np
        import cv2

        ## (1) Grab the rgb frame as PIL.Image
        ii = ImageGrab.grab()
        print(type(ii)) # <class 'PIL.Image.Image'>

        ## (2) Convert PIL.Image to np.array
        rgb = np.array(ii)
        print(type(ii)) # <class 'numpy.ndarray'>

        ## (3) Convert into BGR and display
        bgr = cv2.cvtColor(rgb, cv2.COLOR_RGB2BGR)
        # img_gray = cv2.cvtColor(rgb, cv2.COLOR_BGR2GRAY)
        cv2.imshow("frame", bgr)
        cv2.waitKey()
        cv2.destroyAllWindows()
        
    固定区域截图
        box = (x,y,x1,y1)
        im = ImageGrab.grab(box)
    
    像素颜色匹配
        getpixel(pos)
            pix = pyautogui.pixel(100, 200)
            >>> pix
            RGB(red=130, green=135, blue=144)
            
        pixelMatchesColor(pos, (140, 125, 134), tolerance=10)
            >>> pyautogui.pixelMatchesColor(100, 200, (130, 135, 144))
            True
            >>> pyautogui.pixelMatchesColor(100, 200, (140, 125, 134))
            False
            >>> pyautogui.pixelMatchesColor(100, 200, (140, 125, 134), tolerance=10)
            
    debug
        log_screnshort()
        每次操作，都保存操作描述和一个截图对象到队列中（size 10）
        如果发生异常，截屏，并把最近的10个操作的截图写到debug文件夹
        
    api
        position()  # current mouse x and y
        
        onScreen(x, y)  # True if x & y are within the screen.
        
        moveTo(x, y, duration=num_seconds)  # move mouse to XY coordinates over num_second seconds
        
        dragTo(x, y, duration=num_seconds)  # drag mouse to XY
        
        scroll(amount_to_scroll, x=moveToX, y=moveToY)
        
        screenshot()  # returns a Pillow/PIL Image object
        
        screenshot('foo.png')  # returns a Pillow/PIL Image object, and saves it to a file
        >>> pyautogui.locateOnScreen('looksLikeThis.png')  # returns (left, top, width, height) of first place it is found
        (863, 417, 70, 13)
        
        >>> for i in pyautogui.locateAllOnScreen('looksLikeThis.png')
        ...
        ...
        (863, 117, 70, 13)
        (623, 137, 70, 13)
        (853, 577, 70, 13)
        (883, 617, 70, 13)
        (973, 657, 70, 13)
        (933, 877, 70, 13)
        
        >>> pyautogui.locateCenterOnScreen('looksLikeThis.png')  # returns center x and y
        (898, 423)
            
        >>> im.getpixel((100, 200))
        (130, 135, 144)
      
        >>> pyautogui.pixelMatchesColor(100, 200, (140, 125, 134), tolerance=10)
        True
        
        
