btm 密码 qQ198...


git status
git add .
git commit -m

git push origin master
git push origin multi_client
git push --delete origin branch_name_here

git branch
git checkout

git log
                

★ 现在已经实现一键挂机了

下一步是把所有情况都考虑上，提高挂机稳定性
涉及到切界面的要考虑monitor，因为有时候快有时候慢

优化图片，很多图片重复
ok1 ok2，也没法区分

monitor_than_click()
find_then_click(name_list, pos=None, timeout=5, raise_exception=True)


    async def _fight(self):
        """do fight, return win or lose"""
        await self.player.find_then_click(['start_fight', 'fight1'])
        await asyncio.sleep(3)
        await self.player.find_then_click(['fast_forward1'], raise_exception=False)
        await asyncio.sleep(10)
        await self.player.find_then_click(['go_last'])
        pos_ok = (430, 430)
        result = await self.player.find_then_click(['win', 'lose'], pos=pos_ok, timeout=240)
        await asyncio.sleep(3)
        return result
        
        吉安县畜牧兽医局 07968442451
        



换区 change server
    make sure in main ui
    find and click setting
    find and click server icon
    wait until no find empty board
    
    if right top server is new server icon
        return false

    click the right top server icon
    click ok
    find setting
    return true
    
    
关卡战斗
    find and click gkzd
    if no find
        move to center
        find and click gkzd
    wait untile find goback icon
    
    # for ther first 10 days of new player
    if find close btn (1s)
        find and click 'can recive'
        find and click ok
        find and then click close
    
    click box
    click recive btn
    
    monitor [upgraded fight next pass]
    
    if find upgrade(upgrade and unlock new map)
        find and click ok
        sleep 5s
        move to center
        find and click gkzd
        wait untile find goback icon 
        
        monitor [fight next pass]

    if find fight btn
        click
        find and click fight btn
    elif find next level btn
        click
        click search
        wait 3 s (10s, vip at least 3s)
        find and click fight btn
        find and click fight btn
    elif pass
        if find nex_level_point
            click
            if find  search
                click
            else
                return
        else 
            find and click the rightest next_level_flag
            if find search
                click
                if find pass
                    click map
            else
                return
            
    
    while true

        try:
            do fight
                ...
                click ok
                
            monitor [upgrade next]
            if upgrade
                hand_upgrade
            
            nextlevel_to_fight
        except fight_lose:
            return
        except reach_max_level:
            return
            
    


挑战副本
    find and click tzfb
    


公会挑战


勇者副本


VIP shop


主程序逻辑

场景一：一键游戏
    初始化账号列表
    启动多个模拟器
    old_account = None

    对于每个客户端
        try
            account_dict = 登录一个新账号
            old_account = account_dict
        except
            没账号了：exit

        if server_list:
            for 对于每一个服务器
                切换到该的服务器

                玩游戏
        else
            玩游戏

登录一个新账号
    if old_account：
        获取一个账号（指定游戏名）
        if 成功：
            登录
        else
            关闭游戏
            获取一个账号
            根据游戏名，启动游戏
            登录
    else
        获取一个账号
        根据游戏名，启动游戏
        登录
        

场景二：继续游戏 （需要记录哪些角色玩过了，哪些任务已完成）


冠军试炼
    如果不是周日下午
        退出
        如果已经获得了200积分
            退出
    点竞技场
    点冠军试炼
    点进入
    如果 战斗说明
        点 close
        如果英雄出战
            点保存
    i=4
    j=1
    score = 0
    
    while score < 50:
        点战斗
        点 刷新 i 次
        点 j 战斗
        
        点战斗
        monitor
        if 下一场 或 确定 或 快进
            点
        if card
            点卡片 2 次
            if win
                score += 2  
                win += 1
            else
                score += 1
                lose += 1
                j += 1
                if j > 3:
                    j = 1
                    i += 1

            点确定

    log win xx lose yy


英雄远征
hero_expedition
production_workshop
one_click_collection
    到右上角
    点英雄远征
    点生产车间
    点一键领取


模板匹配，会因为大小不同，分辨率不同，匹配失败
    试试特征点匹配


很多按钮突然识别不了了，应该是按钮的指纹变了
=》 可能是截图完整的按钮没问题，只截文字有问题 （文字细节会变化）（如果有多个按钮，可能会误识别）
=》 使用其他标志图标，然后，按位置点击


如何实现一键游戏，做到完全省心？
    图像识别准确
    每个逻辑都独立，并覆盖所有情况
    每个任务都可以配置，做到遵循玩家意愿
    结束后，有个报告，告知任务完成情况，让玩家放心
    即使出现问题，也不影响别的
    出现预料之外的情况，有记录，可追溯
    出现游戏bug，无响应等异常，能重启游戏


开发中遇到的阻碍：
    很多情况没有考虑到
    -》 伪代码

    截图太麻烦
    -> 截有特色的, 使用好的截图软件

    api记不住
    -> Shpinx 自动生成项目文档

    代码框架感觉有点混乱了
    -> 重新理一下


main
    创建 recorder
        加载 json 到 dict

    windows_num = 启动模拟器 (如果已经启动，直接返回窗口数)
    根据窗口数，创建玩家 （固定启动4个）
    
    对于每一个玩家，添加协程任务 auto_play
        try:
            角色 = 登录游戏
        except:
            exit

        对于每一个未完成的任务 + 多多益善的任务（根据json）
            try:
                执行任务 （可能用到 role recorder）
            except:
                xxx

            try：
                回主界面
            except：
                重启游戏
        
    退出之前：
        dict -> json
        

    登录游戏
        if 在主界面了
            if 角色为空
                role = 获取登录的角色名 (退出，复制用户名)
                绑定角色
            else
                role = apply_new_role
                重新登录 role
        else (游戏未启动)
            启动游戏，自动登录游戏
            role = 获取登录的角色名
            try：
                绑定角色
            except
                role = apply_new_role
                重新登录 role

        return role

    重新登录
        退出
        登录 role

先实现不要账号密码的

eye，hand
    提供基础api，方便第一，不考虑效率

player
    和window结合，方便auto_play调用，提供缓存，考虑效率

tasks
    利用 player，role 完成每一个任务

login
    启动模拟器，登录游戏

recorder
    记录每个role的任务完成情况
    load
    record
    report

account.cfg
    game_name = mo_shi_jun_tun
    account = aa592729440
    passwd = Qq8738090

setting.cfg 
    [default]
    cfg of all task ...

    [account1]
    cfg of all task ...

    [account2]
    ...

pics 
    bottom
    icon
    pic

支持各种大小的窗口
    截图最大的窗口，然后通过剪切、缩小，得到各种尺寸的图片

每个player有单独的日志记录

写个测试，测试下，使用with的多进程查找 
    估计不会有性能问题
    
没必要把hand、eye分开，直接都集成到player中去，参考pyautogui

★ eye能够自己保存截屏img，过期了就重新截一个，没过期就还用原来的。
不要让player还去考虑并发，公用截屏img的问题。
至于target_img可以使用global_value来缓存

关于配置，可以直接copy default的，取名game_account.cfg，然后用户想改的话，可以自己改

每一个任务，写成类，调用的时候通过配置来

为了能支持快速停止，所有耗时函数，都需要是协程

☆ 研究下别人的代码实现
    img.resize()
    
    屏幕截图，避免保存和读取的过程
        from PIL import ImageGrab
        from io import BytesIO
        import numpy as np
        import cv2

        ## (1) Grab the rgb frame as PIL.Image
        ii = ImageGrab.grab()
        print(type(ii)) # <class 'PIL.Image.Image'>

        ## (2) Convert PIL.Image to np.array
        rgb = np.array(ii)
        print(type(ii)) # <class 'numpy.ndarray'>

        ## (3) Convert into BGR and display
        bgr = cv2.cvtColor(rgb, cv2.COLOR_RGB2BGR)
        # img_gray = cv2.cvtColor(rgb, cv2.COLOR_BGR2GRAY)
        cv2.imshow("frame", bgr)
        cv2.waitKey()
        cv2.destroyAllWindows()
        
    固定区域截图
        box = (x,y,x1,y1)
        im = ImageGrab.grab(box)
    
    像素颜色匹配
        getpixel(pos)
            pix = pyautogui.pixel(100, 200)
            >>> pix
            RGB(red=130, green=135, blue=144)
            
        pixelMatchesColor(pos, (140, 125, 134), tolerance=10)
            >>> pyautogui.pixelMatchesColor(100, 200, (130, 135, 144))
            True
            >>> pyautogui.pixelMatchesColor(100, 200, (140, 125, 134))
            False
            >>> pyautogui.pixelMatchesColor(100, 200, (140, 125, 134), tolerance=10)
            
    debug
        log_screnshort()
        每次操作，都保存操作描述和一个截图对象到队列中（size 10）
        如果发生异常，截屏，并把最近的10个操作的截图写到debug文件夹
        
    api
        position()  # current mouse x and y
        
        onScreen(x, y)  # True if x & y are within the screen.
        
        moveTo(x, y, duration=num_seconds)  # move mouse to XY coordinates over num_second seconds
        
        dragTo(x, y, duration=num_seconds)  # drag mouse to XY
        
        scroll(amount_to_scroll, x=moveToX, y=moveToY)
        
        screenshot()  # returns a Pillow/PIL Image object
        
        screenshot('foo.png')  # returns a Pillow/PIL Image object, and saves it to a file
        >>> pyautogui.locateOnScreen('looksLikeThis.png')  # returns (left, top, width, height) of first place it is found
        (863, 417, 70, 13)
        
        >>> for i in pyautogui.locateAllOnScreen('looksLikeThis.png')
        ...
        ...
        (863, 117, 70, 13)
        (623, 137, 70, 13)
        (853, 577, 70, 13)
        (883, 617, 70, 13)
        (973, 657, 70, 13)
        (933, 877, 70, 13)
        
        >>> pyautogui.locateCenterOnScreen('looksLikeThis.png')  # returns center x and y
        (898, 423)
            
        >>> im.getpixel((100, 200))
        (130, 135, 144)
      
        >>> pyautogui.pixelMatchesColor(100, 200, (140, 125, 134), tolerance=10)
        True
        
        

V1.0


TODO
    发生异常，保存最近10次的屏幕log    done
    给各种查找、操作都加上缓存截图     done
    fix 家园      done
        刚进家园，迷雾没散，点击卡住  done
        点切换地图，地图没弹出来
        识别boos，会误识别
            => 多加几个图片
            滑动后，停0.5s
        _goto_floor 总共7层没问题，但总共是5层呢
        
        战斗，不能用find_all，因为打完一个，下一次回到主界面，位置会变的，需要重新查找
        done
        
        
    
    fix 任务
        """300次必出7星是每天重置的，所有要尽量节约信封,留到人工一次性用来刷7星任务。
        高星任务出现的概率是固定的，一切技巧都是心理作用
        """
        点任务栏
        如果 没有未领任务：
            return
            
        领任务
        完成所有任务 （优先一键领取）
        
        while 还有未领任务:
            try:
                刷新任务
                领任务
            except:
                xxx

        
            
        领任务
            往右滑（划完要停一下），遇到满足要求的就领取
            如果有任务没法领：
                raise
            直到遇到完成，或者解锁，
           
            
        刷新任务
            钻石不足：
                raise

        完成所有任务
            一键领取
            如果失败：
                到最左边
                往右滑（划完要停一下），遇到完成的就领取
                遇到解锁：
                    退出
    
    
    点击的时候，也要截图，否则，图片可能失实    done
    游戏主界面，刚弹出广告，监控到了，点关闭。结果广告才完全出来
    
    图像识别和点击还是有问题，有各种意外
    => 每一个操作都要有确认机制
    
    把图片合并到一个文件夹，不要开发太麻烦了    done
    
    ★ 鼠标双击，经常失灵。
    =》找了半天原因，原来是360导致的。关掉后，又快又好。
    
    ★ 不能有死循环
    所有while True 都要改成 for max_count
    
    物品买了，就变灰色，图像识别到了，又点击怎么办？
    =》
    1 点了，不弹出确认框，就认为买过了
    
    2 加入颜色验证
    pyautogui.pixelMatchesColor(100, 200, (140, 125, 134), tolerance=10)
    True
    
    _goto_floor 不准确，主函数那边要做处理
    
    go_back 失败，
    =》可能是鼠标不在里面，窗口没有处于激活状态
    换成点回退键，点close的方法？
    
    有时候点击失败
    =》点击太快了，游戏未响应   done
    
    log要分开记录，不然不好分析
    
    有不少误识别，需要提高阈值，到0.9？
    
    is_enabled_button(pos, img_rectangle)
        获取左右两边中点的坐标，如果都是绿色，或者都是黄色
        方圆20个像素,随机10个点
            if pyautogui.pixelMatchesColor(x + dx, y, color, tolerance=10):
                return True
        else:
            return False

    go_back => go_back_to   done    
    win 误识别  =>  0.9     done
    
    
    fix 冠军竞技场   done

    fix 勇士塔     done

        塔
        点点点
        while True
            挑战
            战斗
            while
                下一关，邀请英雄、快进、结束、
                if 下一关
                    break
                if 邀请英雄:
                    ok
                    return

            
            




    
    fix 市场  done
        点市场
        金币、钻石
        领幸存奖励
            back
        while True
            买东西
            刷新， 如果要钻石，则退出
        买高级东西
        
    
    fix 勇者  done
        勇者副本
        当前关卡
        
        挑战
        如果没兵
            派兵
            
        while true:
            开始战斗
            战斗
                    
            如果win
                下一关卡，确定
                    if下一关卡
                        就点下一关卡，点挑战
                    if确定
                        就点确定，找当前关卡
                    点挑战
            else：
                点ok
                
        战斗
            while：
                卡片，lose 结束 快进
                如果 快进，结束：
                    点击
                卡片
                    点两次，return win
                lose
                    return lose
                sleep 1
            
        
    
    fix 公会战
    

    